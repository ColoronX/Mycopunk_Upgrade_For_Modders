<!DOCTYPE html><html lang="en" data-theme="dark"><head>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-NTX1YS21Y0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-NTX1YS21Y0');
</script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Mycopunk Upgrade Solver & Generator</title>
<style>
  :root { 
    --bg-body: #fafafa;
    --bg-panel: #ffffff;
    --bg-input: #ffffff;
    --bg-hover: #f3f3f3;
    --bg-code: #1e1e1e;
    
    --fg-primary: #222222;
    --fg-secondary: #555555;
    --fg-badge: #444444;
    
    --border: #dddddd;
    --border-input: #cccccc;
    --border-hover: #aaaaaa;
    
    --stroke: #7a4a2e;
    
    --hex-empty: #ffffff;
    --hex-fill: #333333;
    
    --overlay-bg: rgba(255,255,255,0.7);
    --kbd-bg: #f1f5f9;
    --badge-bg: #f7f7f8;
    
    --panel-w: 380px; 
  }

  [data-theme="dark"] {
    --bg-body: #121212;
    --bg-panel: #1e1e1e;
    --bg-input: #2c2c2c;
    --bg-hover: #383838;
    --bg-code: #000000;
    
    --fg-primary: #e0e0e0;
    --fg-secondary: #aaaaaa;
    --fg-badge: #e0e0e0;
    
    --border: #333333;
    --border-input: #444444;
    --border-hover: #666666;
    
    --stroke: #a67c52;
    
    --hex-empty: #2a2a2a;
    --hex-fill: #e9bb38;
    
    --overlay-bg: rgba(0,0,0,0.7);
    --kbd-bg: #333333;
    --badge-bg: #333333;
  }

  * { box-sizing: border-box; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color: var(--fg-primary); background: var(--bg-body);
    height: 100vh; display: grid; grid-template-rows: auto 1fr;
    transition: background 0.2s, color 0.2s;
  }
  header {
    padding: 10px 14px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
    border-bottom: 1px solid var(--border); background: var(--bg-panel);
  }
  button {
    padding: 8px 12px; border: 1px solid var(--border-input); border-radius: 8px; 
    background: var(--bg-input); color: var(--fg-primary); cursor: pointer;
  }
  button:hover { border-color: var(--border-hover); background: var(--bg-hover); }
  
  main { display: grid; grid-template-columns: 1fr var(--panel-w); min-height: 0; }
 
  #boardWrap {
    position: relative;
    display: grid;
    place-items: start center;
    min-width: 0;
    min-height: 0;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    padding: 12px; 
  }
  #board { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; max-width: 100%; height: auto; }
  
  #overlayMessage {
    position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
    font-size: 20px; font-weight: 600; color: #ff5555; background: var(--overlay-bg);
    pointer-events: auto;
  }
  
  aside {
    border-left: 1px solid var(--border); background: var(--bg-panel); min-width: 0;
    display: grid; grid-template-rows: auto auto 1fr;
    min-height: 0; 
  }
  .sideHeader {
    padding: 10px 12px; border-bottom: 1px solid var(--border); font-weight: 600;
    display:flex; align-items:center; gap:8px;
  }
  #shapeList { overflow: auto; padding: 10px; display: grid; gap: 10px; min-height: 0; }

  .shapeItem {
    display: grid;
    grid-template-rows: auto auto auto; 
    grid-template-columns: 1fr;
    gap: 6px;
    padding: 8px; border: 1px solid var(--border); border-radius: 10px;
    background: var(--bg-body);
  }
  .shapeTop { display:flex; align-items:center; justify-content:flex-start; }
  .shapeMid { display:grid; grid-template-columns: 1fr auto; align-items:center; gap:10px; }
  .shapeBottom { display:flex; align-items:center; justify-content:flex-start; }
  .shapeMeta { display:flex; align-items:center; gap:10px; } 
  .midControls { display:flex; flex-direction:column; gap:6px; align-items:flex-end; }

  .shapeItem canvas { background: var(--bg-panel); border: 1px dashed var(--border); border-radius: 8px; }
  .shapeItem button { padding: 6px 8px; }
  .hint { opacity: 0.8; font-size: 12px; color: var(--fg-secondary); }
  .grow { flex: 1 1 auto; }
  
  .solControls { display:flex; align-items:center; gap:8px; }
  .solControls input[type="number"] { width: 72px; padding:6px 8px; border:1px solid var(--border-input); border-radius:8px; background: var(--bg-input); color: var(--fg-primary); }
  .pill { padding: 6px 10px; border:1px solid var(--border); border-radius: 999px; background:var(--badge-bg); color: var(--fg-secondary); }
  
  .sizeControls { display:flex; align-items:center; gap:6px; }
  .sizeControls input[type="number"] { width: 64px; padding:6px 8px; border:1px solid var(--border-input); border-radius:8px; background: var(--bg-input); color: var(--fg-primary); }
  .xsep { opacity:.6; }
  
  .check { display:flex; align-items:center; gap:6px; user-select:none; color: var(--fg-primary); }
  .check input { transform: translateY(1px); }
  
  .badge { padding:2px 8px; border:1px solid var(--border); border-radius:999px; font-size:12px; background:var(--badge-bg); color:var(--fg-badge); }
  .sideHint { padding:10px 12px; border-bottom:1px solid var(--border); color:var(--fg-secondary); font-size:12px; background:var(--bg-body); }
  .sideHint kbd { font: 500 11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:var(--kbd-bg); border:1px solid var(--border); padding:2px 6px; border-radius:6px; color: var(--fg-primary); }

  /* Ghost button style */
  .btn-ghost {
    padding: 6px 10px; border: 1px solid var(--border-input); border-radius: 8px; background: var(--bg-panel); cursor: pointer; font-size: 12px; color: var(--fg-primary);
  }
  .btn-ghost:hover { border-color: var(--border-hover); background: var(--bg-hover); }
  
  .btn-code { background: rgba(46, 139, 87, 0.1); border-color: #2e8b57; color: #2e8b57; }
  .btn-code:hover { background: rgba(46, 139, 87, 0.2); }
  [data-theme="dark"] .btn-code { color: #4ade80; border-color: #4ade80; }

  .adjRow { display:flex; align-items:center; gap:6px; width: 100%; }
  .adjRow .check { margin-right: auto; }
  .adjRow input[type="number"] { width: 64px; padding:6px 8px; border:1px solid var(--border-input); border-radius:8px; background: var(--bg-input); color: var(--fg-primary); }
  .indexBadge { font-weight:600; }

  #codeModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 999;
    display: none; align-items: center; justify-content: center;
  }
  #codeContent {
    background: var(--bg-panel); padding: 20px; border-radius: 12px; width: 650px; max-width: 95%;
    box-shadow: 0 10px 25px rgba(0,0,0,0.3); display: flex; flex-direction: column; gap: 10px;
    border: 1px solid var(--border);
    color: var(--fg-primary);
  }
  #codeArea {
    width: 100%; height: 350px; font-family: 'Consolas', 'Monaco', monospace; font-size: 13px;
    padding: 12px; border: 1px solid var(--border-input); border-radius: 6px; resize: vertical; 
    background: var(--bg-code); color: #d4d4d4; white-space: pre;
  }
  .modalHeader { display: flex; justify-content: space-between; align-items: center; }
  .modalActions { display: flex; justify-content: flex-end; gap: 10px; margin-top: 10px;}
</style>
</head>
<body>
  <header>
    <button id="btnAdd">âž• Add shape</button>
    <button id="btnSolve">ðŸ”Ž Find placement</button>
    <button id="btnClear">ðŸ§¹ Clear</button>

    <label class="check" title="Include rotated variants of shapes during search">
      <span class="hint">Disable Rotation</span>
      <input type="checkbox" id="disableRotation">
    </label>

    <div class="sizeControls">
      <span class="hint">Board</span>
      <input id="inpW" type="number" min="1" max="50" value="7">
      <span class="xsep">Ã—</span>
      <input id="inpH" type="number" min="1" max="50" value="6">
    </div>

    <button id="btnTheme" title="Toggle Dark Mode">ðŸŒ™</button>

    <div class="grow"></div>
    <div class="solControls">
      <label class="hint">Max solutions</label>
      <input id="maxSol" type="number" min="1" max="200" value="5">
      <button id="btnPrev" disabled="">â—€</button>
      <span id="solInfo" class="pill hint">0 / 0</span>
      <button id="btnNext" disabled="">â–¶</button>
    </div>
  </header>

  <main>
    <div id="boardWrap">
      <canvas id="board" width="900" height="560"></canvas>
      <div id="overlayMessage">No placement available</div>
    </div>
    <aside>
      <div class="sideHeader">
        <strong>Shapes</strong>
        <span id="shapeCount" class="badge">0</span>
        <button id="btnRemoveAll" class="btn-ghost" style="display:none;">Remove all</button>
      </div>
      <div id="emptyState" class="sideHint">Draw a shape on the board by clicking cells, then press <b>Add shape</b> (or hit <kbd>Enter</kbd>) to save it here.</div>
      <div id="shapeList"></div>
    </aside>
  </main>

  <div id="codeModal">
    <div id="codeContent">
      <div class="modalHeader">
        <h3 style="margin:0">C# Property Code</h3>
        <label class="check">
            <span class="hint">Generate Connections</span>
            <input type="checkbox" id="chkAutoConnect" checked> 
        </label>
      </div>
      <textarea id="codeArea" readonly></textarea>
      <div class="modalActions">
        <button id="btnCopyCode" class="btn-ghost">Copy Code</button>
        <button id="btnCloseModal" class="btn-ghost">Close</button>
      </div>
    </div>
  </div>

<script>
const COLORS = [
  "#e6194b","#3cb44b","#0082c8","#f58231","#911eb4","#46f0f0",
  "#f032e6","#d2f53c","#fabebe","#008080","#e6beff","#aa6e28",
  "#800000","#aaffc3","#808000","#ffd8b1","#000080","#808080",
  "#ffe119","#bfef45","#82b1ff","#ffd700","#90ee90","#ff7f50",
  "#87ceeb","#ff69b4","#cd5c5c","#20b2aa","#b0c4de","#dda0dd",
  "#7fffd4","#ffe4e1","#6a5acd","#2e8b57","#ff8c00","#8fbc8f",
  "#1e90ff","#c71585","#00ced1","#f0e68c"
];

/* ================================
 *  Small helpers
 * ================================ */
const toKey = (x,y) => `${x},${y}`;
const fromKey = k => k.split(',').map(Number);
const cmpCoord = (a,b) => a[0] - b[0] || a[1] - b[1];
const cloneCells = cells => cells.map(([x,y]) => [x,y]);
function canonicalKey(cells) { const arr = cells.map(([x,y]) => `${x},${y}`); arr.sort(); return arr.join(';'); }

/* ================================
 *  Odd-q <-> Axial <-> Cube
 * ================================ */
function oddq_to_axial([col,row]) {
  const parity = (col % 2 === 0) ? 0 : 1;
  const q = col;
  const r = row - Math.floor((col + parity)/2);
  return [q, r];
}
function axial_to_oddq([q,r]) {
  const parity = (q % 2 === 0) ? 0 : 1;
  const col = q;
  const row = r + Math.floor((q + parity)/2);
  return [col, row];
}
function axial_to_cube([x,y]) { return [x, y, -x - y]; }
function cube_to_axial(x,y,z) { return [x,y]; }
function oddq_to_cube(coord) { return axial_to_cube(oddq_to_axial(coord)); }
function cube_to_oddq(x,y,z) { return axial_to_oddq(cube_to_axial(x,y,z)); }
function _cube_rotate_steps(x,y,z,steps) {
  let s = ((steps % 6) + 6) % 6;
  for (let i=0;i<s;i++) [x,y,z] = [-z, -x, -y];
  return [x,y,z];
}

/* ================================
 *  Code Generation Helpers
 * ================================ */
function getNeighborOffsets(isEvenCol) {
    if (isEvenCol) {
        return [
            { dx: 0, dy: -1, name: 'North',      flag: 1 },
            { dx: 1, dy: -1, name: 'NorthEast',  flag: 2 },
            { dx: 1, dy: 0,  name: 'SouthEast',  flag: 4 },
            { dx: 0, dy: 1,  name: 'South',      flag: 8 },
            { dx: -1, dy: 0, name: 'SouthWest',  flag: 16 },
            { dx: -1, dy: -1,name: 'NorthWest',  flag: 32 }
        ];
    } else {
        return [
            { dx: 0, dy: -1, name: 'North',      flag: 1 },
            { dx: 1, dy: 0,  name: 'NorthEast',  flag: 2 },
            { dx: 1, dy: 1,  name: 'SouthEast',  flag: 4 },
            { dx: 0, dy: 1,  name: 'South',      flag: 8 },
            { dx: -1, dy: 1, name: 'SouthWest',  flag: 16 },
            { dx: -1, dy: 0, name: 'NorthWest',  flag: 32 }
        ];
    }
}

function normalizeForExport(cells) {
    if (!cells.length) return [];
    let minX = Infinity, minY = Infinity;
    cells.forEach(([x,y]) => {
        if(x < minX) minX = x;
        if(y < minY) minY = y;
    });

    const norm = [];
    let newMinY = Infinity;

    cells.forEach(([x,y]) => {
        let nx = x - minX;
        let ny = y - minY;
        
        // Parity correction for visual/game logic preservation: 
        if ((x % 2 !== 0) && (nx % 2 === 0)) {
            ny += 1; 
        }
        
        norm.push([nx, ny]);
        if (ny < newMinY) newMinY = ny;
    });

    if (newMinY < 0) {
        norm.forEach(c => c[1] -= newMinY);
    } else if (newMinY > 0) {
        norm.forEach(c => c[1] -= newMinY);
    }
    return norm;
}

function generateCSharp(cells, autoConnect) {
    const norm = normalizeForExport(cells);
    const map = new Map();
    norm.forEach(([x,y]) => map.set(`${x},${y}`, { x, y, degree: 0 }));

    map.forEach(info => {
        const isEven = (info.x % 2 === 0);
        getNeighborOffsets(isEven).forEach(o => {
            if (map.has(`${info.x + o.dx},${info.y + o.dy}`)) info.degree++;
        });
    });

    const hasPriority = (a, b) => {
        if (a.degree !== b.degree) return a.degree > b.degree;
        if (a.y !== b.y) return a.y < b.y;
        return a.x < b.x;
    };

    let w = 0, h = 0;
    norm.forEach(([x,y]) => { w = Math.max(w, x); h = Math.max(h, y); });
    w = Math.max(3, w + 1); h = Math.max(3, h + 1);
    
    norm.sort((a,b) => a[0] - b[0] || a[1] - b[1]);

    let sb = `protected override HexMap Pattern\n{\n\tget\n\t{\n\t\tHexMap m = new HexMap(${w}, ${h});\n`;
    norm.forEach(([x,y]) => {
        sb += `\t\tm[${x}, ${y}].enabled = true;`;
        if (autoConnect) {
            const me = map.get(`${x},${y}`);
            const isEven = (x % 2 === 0);
            const flags = [];
            getNeighborOffsets(isEven).forEach(o => {
                const nKey = `${x + o.dx},${y + o.dy}`;
                if (map.has(nKey) && hasPriority(me, map.get(nKey))) {
                    flags.push(`HexMap.Direction.${o.name}`);
                }
            });
            if (flags.length) sb += ` m[${x}, ${y}].connections = ${flags.join(" | ")};`;
        }
        sb += `\n`;
    });
    sb += `\t\treturn m;\n\t}\n}`;
    return sb;
}
/* ================================
 *  Shape utilities
 * ================================ */
function get_pivot(cells) {
  return cells.reduce((best, cur) => {
    if (!best) return cur;
    if (cur[0] < best[0]) return cur;
    if (cur[0] === best[0] && cur[1] < best[1]) return cur;
    return best;
  }, null);
}
function normalize_shape(cells) {
  if (!cells || !cells.length) return [];
  let min_x = Infinity, min_y = Infinity;
  for (const [x,y] of cells) { if (x < min_x) min_x = x; if (y < min_y) min_y = y; }
  const normalized = [];
  for (const [x,y] of cells) {
    let nx = x - min_x;
    let ny = y - min_y;
    if (x % 2 === 1 && nx % 2 === 0) ny -= 1;
    normalized.push([nx, ny]);
  }
  const set = new Set(normalized.map(([a,b]) => toKey(a,b)));
  return Array.from(set, fromKey).sort(cmpCoord);
}
function move_shape(cells, dx, dy, max_width, max_height) {
  if (!cells || !cells.length) return [];
  const [px,py] = get_pivot(cells);
  const pivot_parity = px % 2;
  const moved = [];
  for (const [x,y] of cells) {
    const offset_x = x - px;
    const offset_y = y - py;
    let new_x = px + dx + offset_x;
    let new_y = py + dy + offset_y;
    if (!(x === px && y === py) && (x % 2 !== pivot_parity)) {
      if (x % 2 === 1 && new_x % 2 === 0) new_y -= 1;
      else if (x % 2 === 0 && new_x % 2 === 1) new_y += 1;
    }
    if (!(0 <= new_x && new_x < max_width && 0 <= new_y && new_y < max_height)) return null;
    moved.push([new_x, new_y]);
  }
  const set = new Set(moved.map(([a,b])=>toKey(a,b)));
  return Array.from(set, fromKey).sort(cmpCoord);
}
function rotate_cells_about_pivot_oddq(cells, times) {
  if (!cells || !cells.length) return [];
  let s = ((times % 6) + 6) % 6;
  if (s === 0) return cloneCells(cells);
  const pivot = get_pivot(cells);
  const [pcx,pcy,pcz] = oddq_to_cube(pivot);
  const out = new Set();
  for (const [col,row] of cells) {
    let [cx,cy,cz] = oddq_to_cube([col,row]);
    cx -= pcx; cy -= pcy; cz -= pcz;
    [cx,cy,cz] = _cube_rotate_steps(cx,cy,cz,s);
    cx += pcx; cy += pcy; cz += pcz;
    const [nx,ny] = cube_to_oddq(cx,cy,cz);
    out.add(toKey(nx,ny));
  }
  return Array.from(out, fromKey).sort(cmpCoord);
}
function rotate_shape(cells, times, max_width, max_height) {
  if (!cells || !cells.length) return [];
  const rotated = rotate_cells_about_pivot_oddq(cells, times);
  for (const [x,y] of rotated) if (!(0 <= x && x < max_width && 0 <= y && y < max_height)) return null;
  return rotated;
}

/* ================================
 *  Axial offsets (placement math)
 * ================================ */
function offsetsFromPivotAxial(cells) {
  const pivot = get_pivot(cells);
  const [pq, pr] = oddq_to_axial(pivot);
  const offs = [];
  for (const c of cells) {
    const [q, r] = oddq_to_axial(c);
    offs.push([q - pq, r - pr]);
  }
  offs.sort((a,b) => a[0] - b[0] || a[1] - b[1]);
  return offs;
}
function offsetsKey(offs) { return offs.map(([dq,dr]) => dq + "," + dr).join(";"); }

/* ================================
 *  Drawing (Canvas) â€” hex
 * ================================ */
function drawHex(ctx, cx, cy, r, fill, stroke, alpha=1) {
  const strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--stroke').trim();
  ctx.save();
  ctx.beginPath();
  for (let i=0;i<6;i++) {
    const ang = (Math.PI/180) * (60*i + 60);
    const vx = cx + r * Math.cos(ang);
    const vy = cy + r * Math.sin(ang);
    if (i===0) ctx.moveTo(vx,vy); else ctx.lineTo(vx,vy);
  }
  ctx.closePath();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = fill; ctx.fill();
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1; ctx.strokeStyle = stroke || strokeColor; ctx.stroke();
  ctx.restore();
}

/* ================================
 *  HexBoard (0,0 at bottom-left)
 * ================================ */
class HexBoard {
  constructor(width, height, canvas) {
    this.radius = 40;
    this.dx = 1.5 * this.radius;
    this.dy = Math.sqrt(3) * this.radius;
    this.marginX = 150;
    this.marginY = 150;

    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.filled = new Map();
    this.hexCenters = new Map();

    this.setSize(width, height);
  }

  setSize(width, height) {
    this.width = Math.max(1, Math.min(50, Number(width) || 1));
    this.height = Math.max(1, Math.min(50, Number(height) || 1));
    this.cells = [];
    for (let y=0;y<this.height;y++) for (let x=0;x<this.width;x++) this.cells.push([x,y]);
    this.clear_all();
    this.updateCanvasSize();
    this.draw();
  }

  updateCanvasSize() {
    const spanX = this.dx * (this.width - 1);
    const spanY = this.dy * (this.height - 1);
    const pxW = Math.ceil(this.marginX * 2 + spanX);
    const pxH = Math.ceil(this.marginY * 2 + spanY);
    this.canvas.width = pxW;
    this.canvas.height = pxH;
  }
  
   // Returns: true if changed, boolean if mode is null (read), null if missed
  set_cell(mouseX, mouseY, mode) {
    let chosen = null, bestD2 = Infinity;
    for (const [k,[cx,cy]] of this.hexCenters.entries()) {
      const dx = mouseX - cx, dy = mouseY - cy;
      const d2 = dx*dx + dy*dy;
      if (d2 < this.radius*this.radius && d2 < bestD2) { bestD2 = d2; chosen = k; }
    }
    if (!chosen) return null;
    
    // Read mode
    if (mode === null) return this.filled.has(chosen);
    
    // Write mode
    if (mode && !this.filled.has(chosen)) { this.filled.set(chosen, "black"); return true; }
    if (!mode && this.filled.has(chosen)) { this.filled.delete(chosen); return true; }
    return false;
  }

  cell_center(x,y) {
    const yDown = (this.height - 1 - y);
    const draw_x = this.dx * x + this.marginX;
    const draw_y = this.dy * yDown - (x % 2 ?  0 : (this.dy / 2)) + this.marginY;
    return [draw_x, draw_y];
  }

  draw() {
    const ctx = this.ctx;
    // Get colors from CSS variables for current theme
    const emptyColor = getComputedStyle(document.body).getPropertyValue('--hex-empty').trim();
    const fillColor = getComputedStyle(document.body).getPropertyValue('--hex-fill').trim();
    
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    this.hexCenters.clear();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.font = '10px system-ui';

    for (const [x,y] of this.cells) {
      const [cx,cy] = this.cell_center(x,y);
      const val = this.filled.get(toKey(x,y));
      // If cell is part of shape/solution, use that color. If it's a "user selection", use the theme specific fill.
      let color = val;
      if (!val) color = emptyColor;
      else if (val === "black") color = fillColor;

      drawHex(ctx, cx, cy, this.radius, color, null, 1);
      this.hexCenters.set(toKey(x,y), [cx,cy]);
    }
  }

  drawMessage(msg) {
    const overlay = document.getElementById('overlayMessage');
    overlay.textContent = msg;
    overlay.style.display = 'flex';
    overlay.dataset.active = '1';
  }

  hideMessage() {
    const overlay = document.getElementById('overlayMessage');
    overlay.style.display = 'none';
    delete overlay.dataset.active;
  }

  toggle_cell(mouseX, mouseY) {
    let chosen = null, bestD2 = Infinity;
    for (const [k,[cx,cy]] of this.hexCenters.entries()) {
      const dx = mouseX - cx, dy = mouseY - cy;
      const d2 = dx*dx + dy*dy;
      if (d2 < this.radius*this.radius && d2 < bestD2) { bestD2 = d2; chosen = k; }
    }
    if (!chosen) return false;
    if (this.filled.has(chosen)) this.filled.delete(chosen);
    else this.filled.set(chosen, "black"); // We still store "black" as a key for selection, but draw logic maps it to var
    return true;
  }

  clear_all() { this.filled.clear(); }
}

/* ================================
 *  Shape
 * ================================ */
class Shape {
  constructor(cells, color) {
    this.cells = cloneCells(cells);
    this.color = color;
    this.pivot = get_pivot(this.cells) || [0,0];
    this.prism = false;          // whether this shape must be adjacent to other prisms
    this.adjacentTo = null;      // index (0-based) of the shape it must touch; null = disabled
  }

  drawToCanvas(canvas) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const norm = normalize_shape(this.cells);

    const radius = 12;
    const dx = 1.5 * radius;
    const dy = Math.sqrt(3) * radius;

    let maxx = 0, maxy = 0;
    for (const [x,y] of norm) { if (x>maxx) maxx=x; if (y>maxy) maxy=y; }

    const w = dx*maxx + 2*radius, h = dy*maxy + 2*radius;
    const offx = (canvas.width - w)/2 + radius;
    const offy = (canvas.height - h)/2 + radius;

    for (const [x,y] of norm) {
      const yDown = (maxy - y);
      const cx = offx + dx * x;
      const cy = offy + dy * yDown - (x % 2 ? 0 : (dy/2));
      drawHex(ctx, cx, cy, radius, this.color, null, 0.8);
    }
  }

  rotations() {
    const res = [];
    const seen = new Set();
    for (let i=0;i<6;i++) {
      const rot = rotate_cells_about_pivot_oddq(this.cells, i);
      const key = canonicalKey(rot);
      if (!seen.has(key)) { seen.add(key); res.push(rot); }
    }
    return res;
  }

  rotate_about_pivot(times) { return rotate_cells_about_pivot_oddq(this.cells, times); }
}

/* ================================
 *  Worker factory + chunk util
 * ================================ */
function createSolverWorkerURL() {
  const src = `
    self.onmessage = (e) => {
      const { placements_ordered, sizes_ordered, board_cells, seeds, limit } = e.data;
      const n = placements_ordered.length;

      const remain = new Array(n + 1).fill(0);
      for (let i = n - 1; i >= 0; i--) remain[i] = remain[i + 1] + sizes_ordered[i];

      function bitCount(x) { let c = 0; while (x) { x &= (x - 1n); c++; } return c; }

      const solutions = [];

      function dfs(depth, occ, chosen) {
        if (solutions.length >= limit) return false;
        const free = board_cells - bitCount(occ);
        if (remain[depth] > free) return false;
        if (depth === n) { solutions.push(chosen.slice()); return solutions.length < limit; }

        const plist = placements_ordered[depth];
        for (let i = 0; i < plist.length; i++) {
          const mask = plist[i];
          if ((mask & occ) !== 0n) continue;
          chosen[depth] = mask;
          if (!dfs(depth + 1, occ | mask, chosen)) return false;
        }
        return true;
      }

      for (let s = 0; s < seeds.length; s++) {
        if (solutions.length >= limit) break;
        const seed = seeds[s];
        const chosen = new Array(n).fill(0n);
        chosen[0] = seed;
        dfs(1, seed, chosen);
      }
      postMessage({ ok: solutions.length > 0, solutions });
    };
  `;
  return URL.createObjectURL(new Blob([src], { type: "text/javascript" }));
}
function chunk(arr, k) {
  const out = [];
  const size = Math.ceil(arr.length / k);
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

/* ================================
 *  App
 * ================================ */
class App {
  constructor() {
    this.canvas = document.getElementById('board');
    this.board = new HexBoard(7, 6, this.canvas);

    // UI
    document.getElementById('btnAdd').addEventListener('click', () => this.add_shape());
    document.getElementById('btnSolve').addEventListener('click', () => this.find_placement());
    document.getElementById('btnClear').addEventListener('click', () => this.clear_board());
    document.getElementById('btnPrev').addEventListener('click', () => this.showPrevSolution());
    document.getElementById('btnNext').addEventListener('click', () => this.showNextSolution());
    document.getElementById('btnRemoveAll').addEventListener('click', () => this.remove_all_shapes());

    // Theme UI
    document.getElementById('btnTheme').addEventListener('click', () => this.toggleTheme());

    // Modal UI
    document.getElementById('btnCopyCode').addEventListener('click', () => {
        const ta = document.getElementById('codeArea');
        ta.select();
        navigator.clipboard.writeText(ta.value);
    });
    document.getElementById('btnCloseModal').addEventListener('click', () => {
        document.getElementById('codeModal').style.display = 'none';
    });
    document.getElementById('chkAutoConnect').addEventListener('change', () => this.refreshCodeModal());

    // size controls (auto-apply on input/change)
    this.inpW = document.getElementById('inpW');
    this.inpH = document.getElementById('inpH');
    const debounce = (fn, ms = 200) => { let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn.apply(this, args), ms); }; };
    const debouncedApply = debounce(() => this.applySize(), 200);
    ['input','change'].forEach(evt => {
      this.inpW.addEventListener(evt, debouncedApply);
      this.inpH.addEventListener(evt, debouncedApply);
    });

    // Drag-to-paint logic
    let isDragging = false;
    let dragFillMode = true;

    const getMousePos = (ev) => {
      const rect = this.canvas.getBoundingClientRect();
      const scaleX = this.canvas.width  / rect.width;
      const scaleY = this.canvas.height / rect.height;
      return [(ev.clientX - rect.left) * scaleX, (ev.clientY - rect.top) * scaleY];
    };

    this.canvas.addEventListener('mousedown', (ev) => {
      const [x, y] = getMousePos(ev);
      const currentState = this.board.set_cell(x, y, null); // Read state
      if (currentState === null) return; // Clicked whitespace

      isDragging = true;
      dragFillMode = !currentState; // Invert clicked cell (Toggle behavior)
      
      if (this.board.set_cell(x, y, dragFillMode)) this.redraw();
    });

    this.canvas.addEventListener('mousemove', (ev) => {
      if (!isDragging) return;
      const [x, y] = getMousePos(ev);
      // Apply the same mode (add or remove) to dragged cells
      if (this.board.set_cell(x, y, dragFillMode)) this.redraw();
    });

    window.addEventListener('mouseup', () => { isDragging = false; });

    // Global click *capture*: if overlay is visible, hide it and swallow the click.
    document.addEventListener('click', (ev) => {
      const overlay = document.getElementById('overlayMessage');
      if (overlay?.dataset.active === '1') {
        this.board.hideMessage();
        ev.stopPropagation();
        ev.preventDefault();
      }
    }, true); // capture phase so we run before any other handlers

    window.addEventListener('keydown', (ev) => this.on_key(ev), { passive: false });

    // Add shape with plain Enter (unless focused in size inputs)
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey) {
        const t = e.target;
        if (t !== this.inpW && t !== this.inpH) { e.preventDefault(); this.add_shape(); }
      }
    });

    // State
    this.shapes = [];
    this.color_index = 0;
    this.activeCodeShape = null;

    this.current_shape_coords = [];
    this.current_shape_color = "black";
    this.current_base = [0,0];

    // Solutions browsing state
    this.solutionMasks = [];
    this.solutionIndex = 0;
    this.decodeHelpers = null;
    this.updateSolutionControls();

    // Check system preference or saved preference
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {
      this.setTheme('light');
    } else {
      this.setTheme('dark');
    }

    this.redraw();
  }

  toggleTheme() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    this.setTheme(isDark ? 'light' : 'dark');
  }

  setTheme(themeName) {
    document.documentElement.setAttribute('data-theme', themeName);
    localStorage.setItem('theme', themeName);
    document.getElementById('btnTheme').textContent = themeName === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
    // Redraw canvas to update colors
    this.redraw();
    // Re-render shape list to update cached canvases
    this.update_shape_list();
  }

  applySize() {
    const W = Math.max(1, Math.min(50, Number(this.inpW.value) || 1));
    const H = Math.max(1, Math.min(50, Number(this.inpH.value) || 1));
    this.inpW.value = String(W);
    this.inpH.value = String(H);

    this.board.hideMessage();
    this.solutionMasks = []; this.solutionIndex = 0; this.decodeHelpers = null; this.updateSolutionControls();
    this.current_shape_coords = [];

    this.board.setSize(W, H);
    this.redraw();
  }

  on_key(event) {
    // Key handlers if needed
  }

  add_shape() {
    if (this.board.filled.size === 0) return;
    const color = COLORS[this.color_index % COLORS.length]; this.color_index++;
    const cells = Array.from(this.board.filled.keys(), fromKey);
    this.shapes.push(new Shape(cells, color));
    this.board.clear_all();
    this.current_shape_coords = [];
    this.board.hideMessage();
    this.solutionMasks = []; this.solutionIndex = 0; this.decodeHelpers = null; this.updateSolutionControls();
    this.redraw();
  }
  remove_shape(index) {
    if (index >= 0 && index < this.shapes.length) {
      this.shapes.splice(index, 1);
      this.redraw();
    }
  }
  remove_all_shapes() {
    if (this.shapes.length === 0) return;
    this.shapes = [];
    this.board.clear_all();
    this.current_shape_coords = [];
    this.board.hideMessage();
    this.solutionMasks = []; this.solutionIndex = 0; this.decodeHelpers = null; this.updateSolutionControls();
    this.redraw();
  }
  clear_board() {
    this.board.clear_all();
    this.current_shape_coords = [];
    this.board.hideMessage();
    this.solutionMasks = []; this.solutionIndex = 0; this.decodeHelpers = null; this.updateSolutionControls();
    this.redraw();
  }

  /* ---------- Modal ---------- */
  openCodeModal(shape) {
    this.activeCodeShape = shape;
    this.refreshCodeModal();
    document.getElementById('codeModal').style.display = 'flex';
  }

refreshCodeModal() {
    if (!this.activeCodeShape) return;
    const auto = document.getElementById('chkAutoConnect').checked;
    
    // IMPORTANT: Invert Y so the Solver's coordinate system matches the Generator's logic
    const cellsForGen = this.activeCodeShape.cells.map(([x,y]) => [x, -y]);
    
    const code = generateCSharp(cellsForGen, auto);
    document.getElementById('codeArea').value = code;
  }

  /* ---------- UI: list with Top/Mid/Bottom rows ---------- */
  update_shape_list() {
    const list = document.getElementById('shapeList');
    const empty = document.getElementById('emptyState');
    const countEl = document.getElementById('shapeCount');
    const removeAllBtn = document.getElementById('btnRemoveAll');
    list.innerHTML = '';

    // Count badge
    if (countEl) countEl.textContent = String(this.shapes.length);

    // Show/hide "Remove all" button
    if (removeAllBtn) removeAllBtn.style.display = this.shapes.length > 0 ? 'inline-block' : 'none';

    // Empty state guidance
    if (this.shapes.length === 0) {
      if (empty) empty.style.display = 'block';
      return;
    }
    if (empty) empty.style.display = 'none';

    // Render list
    this.shapes.forEach((shape, i) => {
      const item = document.createElement('div');
      item.className = 'shapeItem';

      // Top row: index badge
      const topRow = document.createElement('div');
      topRow.className = 'shapeTop';
      const idxBadge = document.createElement('span');
      idxBadge.className = 'badge indexBadge';
      idxBadge.textContent = `#${i}`;
      topRow.appendChild(idxBadge);

      // Middle row: canvas (left) + controls (right)
      const midRow = document.createElement('div');
      midRow.className = 'shapeMid';

      const meta = document.createElement('div');
      meta.className = 'shapeMeta';
      const canvas = document.createElement('canvas');
      canvas.width = 180; canvas.height = 100;
      shape.drawToCanvas(canvas);
      meta.appendChild(canvas);

      const controls = document.createElement('div');
      controls.className = 'midControls';

      const btnCode = document.createElement('button');
      btnCode.textContent = 'Get C# Code';
      btnCode.className = 'btn-ghost btn-code';
      btnCode.addEventListener('click', () => this.openCodeModal(shape));
      controls.appendChild(btnCode);

      const btn = document.createElement('button');
      btn.textContent = 'Remove';
      btn.className = 'btn-ghost';
      btn.addEventListener('click', () => this.remove_shape(i));
      controls.appendChild(btn);

      midRow.appendChild(meta);
      midRow.appendChild(controls);

      // Bottom row: Prism + "Adjacent to" index
      const bottomRow = document.createElement('div');
      bottomRow.className = 'shapeBottom';

      const adjRow = document.createElement('div');
      adjRow.className = 'adjRow';

      const prismWrap = document.createElement('label');
      prismWrap.className = 'check';
      const prismChk = document.createElement('input');
      prismChk.type = 'checkbox';
      prismChk.checked = shape.prism;
      prismChk.addEventListener('change', () => { shape.prism = prismChk.checked; });
      const prismTxt = document.createElement('span');
      prismTxt.textContent = 'Prism';
      prismTxt.className = 'hint';
      prismWrap.appendChild(prismTxt);
      prismWrap.appendChild(prismChk);
      adjRow.appendChild(prismWrap);

      const adjLbl = document.createElement('span');
      adjLbl.className = 'hint';
      adjLbl.textContent = '        Adjacent to';
      const adjInp = document.createElement('input');
      adjInp.type = 'number';
      adjInp.min = '0';
      adjInp.step = '1';
      adjInp.placeholder = 'idx';
      adjInp.value = (Number.isInteger(shape.adjacentTo) ? String(shape.adjacentTo) : '');
      adjInp.addEventListener('input', () => {
        const v = adjInp.value.trim();
        if (v === '') { shape.adjacentTo = null; return; }
        const idx = Number(v);
        if (Number.isInteger(idx) && idx >= 0) {
          shape.adjacentTo = idx;
        } else {
          shape.adjacentTo = null;
        }
      });
      adjRow.appendChild(adjLbl);
      adjRow.appendChild(adjInp);
      bottomRow.appendChild(adjRow);

      // Compose rows
      item.appendChild(topRow);
      item.appendChild(midRow);
      item.appendChild(bottomRow);
      list.appendChild(item);
    });
  }

  updateSolutionControls() {
    const prev = document.getElementById('btnPrev');
    const next = document.getElementById('btnNext');
    const info = document.getElementById('solInfo');
    const total = this.solutionMasks.length;
    prev.disabled = !(total > 1 && this.solutionIndex > 0);
    next.disabled = !(total > 1 && this.solutionIndex < total - 1);
    info.textContent = `${total ? this.solutionIndex + 1 : 0} / ${total}`;
  }
  showPrevSolution() { if (this.solutionIndex > 0) { this.solutionIndex--; this.applySolutionByIndex(this.solutionIndex); } }
  showNextSolution() { if (this.solutionIndex + 1 < this.solutionMasks.length) { this.solutionIndex++; this.applySolutionByIndex(this.solutionIndex); } }

  applySolutionByIndex(idx) {
    if (!this.decodeHelpers) return;
    const { powIndex, indexToCoord, order } = this.decodeHelpers;
    const chosen_masks = this.solutionMasks[idx];
    const placement_map = new Map();
    for (let depth = 0; depth < chosen_masks.length; depth++) {
      const shapeIdx = order[depth];
      const color = this.shapes[shapeIdx].color;
      let m = chosen_masks[depth];
      while (m) {
        const lsb = m & (-m);
        const bit = powIndex.get(lsb.toString());
        const [x,y] = indexToCoord[bit];
        placement_map.set(`${x},${y}`, color);
        m ^= lsb;
      }
    }
    this.board.filled = placement_map;
    this.redraw();
    this.updateSolutionControls();
  }

  /* ================================
   *  Helpers for solver
   * ================================ */
  buildNeighborMasks(W, H) {
    const idx_of = (x,y) => y*W + x;
    const masks = new Array(W*H).fill(0n);
    for (let y=0;y<H;y++) {
      for (let x=0;x<W;x++) {
        const [q,r] = oddq_to_axial([x,y]);
        const nbrsAx = [[+1,0],[+1,-1],[0,-1],[-1,0],[-1,+1],[0,+1]];
        let mask = 0n;
        for (const [dq,dr] of nbrsAx) {
          const [qq, rr] = [q+dq, r+dr];
          const [nx, ny] = axial_to_oddq([qq, rr]);
          if (0 <= nx && nx < W && 0 <= ny && ny < H) {
            const bi = idx_of(nx, ny);
            mask |= (1n << BigInt(bi));
          }
        }
        masks[idx_of(x,y)] = mask;
      }
    }
    return masks;
  }

  /* ================================
   *  Multithreaded solver + Prism + Directed Adjacency constraints
   * ================================ */
  find_placement() {
    this.board.hideMessage();
    this.board.filled.clear();
    this.solutionMasks = []; this.solutionIndex = 0; this.decodeHelpers = null; this.updateSolutionControls();

    if (this.shapes.length === 0) { this.redraw(); return; }

    const W = this.board.width, H = this.board.height;
    const BOARD_CELLS = W * H;
    const total_cells = this.shapes.reduce((s,sh) => s + sh.cells.length, 0);
    if (total_cells > BOARD_CELLS) { this.redraw(); this.board.drawMessage('No placement available'); return; }

    const requestedMax = Math.max(1, Math.min(200, Number(document.getElementById('maxSol').value) || 5));
    const MAX_SOLUTIONS = Math.min(requestedMax, 100);

    const disableRotation = document.getElementById('disableRotation')?.checked ?? false;

    const idx_of = (x,y) => y*W + x;

    // Decode helpers
    const powIndex = new Map();
    const indexToCoord = [];
    for (let i=0;i<BOARD_CELLS;i++) {
      const bit = 1n << BigInt(i);
      powIndex.set(bit.toString(), i);
      indexToCoord.push([i % W, Math.floor(i / W)]);
    }

    // Candidate placements via axial offsets
    const all_shape_placements = [];
    const shape_sizes = [];
    const prism_flags = this.shapes.map(s => !!s.prism);

    // Gather directed adjacency constraints by original index (0-based)
    const adjacentTo = this.shapes.map((s,i) => Number.isInteger(s.adjacentTo) ? s.adjacentTo : -1);
    const anyAdj = adjacentTo.some(t => t >= 0);
    const anyPrism = prism_flags.some(Boolean);

    for (const shape of this.shapes) {
      // Decide orientations based on toggle
      const orientations = disableRotation ? [shape.cells] : shape.rotations();

      const seenOffsets = new Set();
      const rotationOffsets = [];
      for (const rot of orientations) {
        const offs = offsetsFromPivotAxial(rot);
        const key = offsetsKey(offs);
        if (!seenOffsets.has(key)) { seenOffsets.add(key); rotationOffsets.push(offs); }
      }

      let placements = [];
      const sz = shape.cells.length;
      shape_sizes.push(sz);

      for (const offs of rotationOffsets) {
        for (let py=0; py<H; py++) {
          for (let px=0; px<W; px++) {
            const [pq, pr] = oddq_to_axial([px, py]);
            let mask = 0n, ok = true;
            for (const [dq, dr] of offs) {
              const q = pq + dq, r = pr + dr;
              const [cx, cy] = axial_to_oddq([q, r]);
              if (!(0 <= cx && cx < W && 0 <= cy && cy < H)) { ok = false; break; }
              mask |= (1n << BigInt(idx_of(cx, cy)));
            }
            if (ok) placements.push(mask);
          }
        }
      }

      if (placements.length === 0) { this.redraw(); this.board.drawMessage('No placement available'); return; }
      placements = Array.from(new Set(placements.map(m => m.toString())), s => BigInt(s));
      all_shape_placements.push(placements);
    }

    // MRV order
    const order = [...all_shape_placements.keys()].sort((a,b) => all_shape_placements[a].length - all_shape_placements[b].length);
    const placements_ordered = order.map(i => all_shape_placements[i]);
    const sizes_ordered = order.map(i => shape_sizes[i]);
    const prism_ordered = order.map(i => prism_flags[i]);

    // Map original indices <-> depth in search order
    const originalIndexToDepth = new Map(order.map((orig, d) => [orig, d]));

    // Sanitize and build directed constraints in depth space
    const targetDepthForDepth = new Array(order.length).fill(-1);
    const sourcesForDepth = Array.from({length: order.length}, () => []);
    for (let orig = 0; orig < adjacentTo.length; orig++) {
      const targOrig = adjacentTo[orig];
      if (!(targOrig >= 0) || targOrig === orig || targOrig >= adjacentTo.length) continue;
      const dSrc = originalIndexToDepth.get(orig);
      const dTgt = originalIndexToDepth.get(targOrig);
      if (dSrc === undefined || dTgt === undefined) continue;
      targetDepthForDepth[dSrc] = dTgt;      // src must touch tgt
      sourcesForDepth[dTgt].push(dSrc);      // tgt must touch these sources
    }

    // Neighbor masks for adjacency checks (both prism cluster & directed constraints)
    const neighborMasks = this.buildNeighborMasks(W, H);
    const neighborOf = (mask) => {
      let res = 0n;
      let m = mask;
      while (m) {
        const lsb = m & (-m);
        const bit = powIndex.get(lsb.toString());
        res |= neighborMasks[bit];
        m ^= lsb;
      }
      return res;
    };

    // Seeds for parallel enumeration
    const seeds = placements_ordered[0];
    if (!seeds.length) { this.redraw(); this.board.drawMessage('No placement available'); return; }

    const finishWhenReady = (solutions) => {
      if (!solutions.length) {
        this.redraw(); this.board.drawMessage('No placement available'); return;
      }
      this.solutionMasks = solutions;
      this.solutionIndex = 0;
      this.decodeHelpers = { powIndex, indexToCoord, order };
      this.applySolutionByIndex(0);
    };

    // If any Prism or any directed adjacency exists, do single-threaded DFS with constraints
    if (anyPrism || anyAdj) {
      const n = placements_ordered.length;
      const remain = new Array(n + 1).fill(0);
      for (let i = n - 1; i >= 0; i--) remain[i] = remain[i + 1] + sizes_ordered[i];

      const bitCount = (x) => { let c = 0; while (x) { x &= (x - 1n); c++; } return c; };

      const solutions = [];

      const dfs = (depth, occ, chosen, prismUnion, prismPlacedCount) => {
        if (solutions.length >= MAX_SOLUTIONS) return false;

        const free = BOARD_CELLS - bitCount(occ);
        if (remain[depth] > free) return true; // prune

        if (depth === n) {
          solutions.push(chosen.slice());
          return solutions.length < MAX_SOLUTIONS;
        }

        const plist = placements_ordered[depth];
        const isPrism = prism_ordered[depth];

        // Directed adjacency: shapes whose constraint points TO this depth and are already placed
        const mustTouchMasksFromSources = sourcesForDepth[depth]
          .filter(s => s < depth && chosen[s] !== 0n)
          .map(s => chosen[s]);

        // Prism cluster adjacency (if cluster already started)
        const needPrismAdjacency = isPrism && prismPlacedCount > 0;
        const prismBorder = needPrismAdjacency ? neighborOf(prismUnion) : 0n;

        for (let i = 0; i < plist.length; i++) {
          const mask = plist[i];
          if ((mask & occ) !== 0n) continue;

          // Prism adjacency requirement
          if (needPrismAdjacency && (mask & prismBorder) === 0n) continue;

          // Directed: sources that target current must touch this mask
          let ok = true;
          for (const srcMask of mustTouchMasksFromSources) {
            if ((mask & neighborOf(srcMask)) === 0n) { ok = false; break; }
          }
          if (!ok) continue;

          // Directed: if current targets an earlier depth, it must touch that target
          const tDepth = targetDepthForDepth[depth];
          if (tDepth >= 0 && tDepth < depth) {
            const tgtMask = chosen[tDepth];
            if (!tgtMask || (tgtMask & neighborOf(mask)) === 0n) continue;
          }

          chosen[depth] = mask;

          const nextUnion = isPrism ? (prismUnion | mask) : prismUnion;
          const nextCount = isPrism ? (prismPlacedCount + 1) : prismPlacedCount;

          if (!dfs(depth + 1, occ | mask, chosen, nextUnion, nextCount)) return false;
        }
        return true;
      };

      for (let s = 0; s < seeds.length && solutions.length < MAX_SOLUTIONS; s++) {
        const chosen = new Array(placements_ordered.length).fill(0n);
        chosen[0] = seeds[s];
        const firstIsPrism = prism_ordered[0];
        const firstUnion = firstIsPrism ? seeds[s] : 0n;
        const firstCount = firstIsPrism ? 1 : 0;
        if (!dfs(1, seeds[s], chosen, firstUnion, firstCount)) break;
      }
      finishWhenReady(solutions);
      return;
    }

    // ---------- No constraints: multithreaded enumeration ----------
    const haveWorkers = typeof Worker !== 'undefined';
    const THREADS = Math.min(
      seeds.length,
      Math.max(2, Math.min((navigator.hardwareConcurrency || 4), 8))
    );

    if (!haveWorkers || THREADS <= 1) {
      // Single-threaded enumeration up to MAX_SOLUTIONS
      const n = placements_ordered.length;
      const remain = new Array(n + 1).fill(0);
      for (let i = n - 1; i >= 0; i--) remain[i] = remain[i + 1] + sizes_ordered[i];

      const bitCount = (x) => { let c = 0; while (x) { x &= (x - 1n); c++; } return c; };
      const solutions = [];

      const dfs = (depth, occ, chosen) => {
        if (solutions.length >= MAX_SOLUTIONS) return false;
        const free = BOARD_CELLS - bitCount(occ);
        if (remain[depth] > free) return true;
        if (depth === n) { solutions.push(chosen.slice()); return solutions.length < MAX_SOLUTIONS; }

        const plist = placements_ordered[depth];
        for (let i=0;i<plist.length;i++) {
          const mask = plist[i];
          if ((mask & occ) !== 0n) continue;
          chosen[depth] = mask;
          if (!dfs(depth + 1, occ | mask, chosen)) return false;
        }
        return true;
      };

      for (let s = 0; s < seeds.length && solutions.length < MAX_SOLUTIONS; s++) {
        const chosen = new Array(placements_ordered.length).fill(0n);
        chosen[0] = seeds[s];
        dfs(1, seeds[s], chosen);
      }
      finishWhenReady(solutions);
      return;
    }

    // Worker pool enumeration (no constraints)
    const workerURL = createSolverWorkerURL();
    const workers = [];
    const chunks = chunk(seeds, THREADS);
    const perWorkerLimit = Math.max(1, Math.ceil(MAX_SOLUTIONS / chunks.length));
    let pending = chunks.length;
    const allSolutions = [];

    const payloadBase = {
      placements_ordered,
      sizes_ordered,
      board_cells: W*H
    };

    const cleanup = () => {
      workers.forEach(w => { try { w.terminate(); } catch {} });
      URL.revokeObjectURL(workerURL);
    };

    chunks.forEach((seedsChunk) => {
      const w = new Worker(workerURL);
      workers.push(w);
      w.onmessage = (ev) => {
        const { ok, solutions } = ev.data || {};
        if (ok && Array.isArray(solutions)) {
          for (const sol of solutions) {
            if (allSolutions.length < MAX_SOLUTIONS) allSolutions.push(sol);
          }
        }
        pending--;
        if (pending === 0 || allSolutions.length >= MAX_SOLUTIONS) {
          cleanup();
          finishWhenReady(allSolutions);
        }
      };
      w.onerror = () => {
        pending--;
        if (pending === 0) { cleanup(); finishWhenReady(allSolutions); }
      };
      w.postMessage({ ...payloadBase, seeds: seedsChunk, limit: perWorkerLimit });
    });
  }

  redraw() {
    this.board.draw();
    this.update_shape_list();
  }
}

/* Boot */
const app = new App();
</script>
</body></html>


